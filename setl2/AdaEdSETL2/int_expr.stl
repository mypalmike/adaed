--
--$Header: /cs.a/ada/ada/src/ada9x/int_expr.stl,v 1.2 91/01/09 17:33:00 banner Exp $
--
package body int_expr;

  use globals;
  use int_globals;
  use int_attributes;
  use int_objects;
  use int_procs;
  use int_util;
  use adaarith;

--T+ VEVAL: Expression evaluation
procedure veval_proc(rd evalexpr);
--
--  Processes most of the operator forms avaliable to 'veval_' .
--  Evalexpr is the expression to be evaluated. Note that forms
--  generated by the interpreter in course of evalution are
--  indicated by names starting with $ .
--

const
   fix_ops   := { "*fx", "/fx" },

   unary_ops := {"+ui", "+ufl", "+ufx", "-ui", "-ufl", "-ufx",
                "absi", "absfl", "absfx", "not", "row"       };

int_trace("VEVAL_PROC", evalexpr);

--  Forms processed by VEVAL_PROC:
--  ------------------------------
--
  case evalexpr.opcode 
--
-- 
-- An IVALUE can appear as a constant in a VEXPR using the form:
-- 
--   ['ivalue', ivalue]
-- 
-- Here the 'ivalue' tag acts like the LISP QUOTE function and the
-- result of evaluating the VEXPR is merely to return the IVALUE
-- specified by the ivalue entry which is the second component.
-- 
        when "ivalue" =>  
             [-, ivalue] := evalexpr;
             push( ivalue );
--
--
-- Parenthesised Expression
-- Qualified expression
-- For both of these forms, evaluate the enclosed expression.
-- 
       when "()", "qualify" => 
            [-, evalexpr] := evalexpr;
            exec( [[ "veval_", evalexpr ]] );
--
--
--  Discriminant reference :
--
--    This can only legitimately appear when we are within the dummy
--    scope created by create_obj_ when creating the object for a 
--    record with discriminants. In this case, EMAP contains the
--    required discriminant value.
--
       when "discr_ref" => 
            [-, discr_name, discr_itype] := evalexpr;
            push( emap(discr_name) ? global_emap(discr_name)
				   ? evalexpr ); 
--S+ 4.1.1 Indexed Components 
--   ['[]', array_vexpr, subscript_vexpr]
-- 
--   The array_vexpr is a VEXPR which evaluates to the array IVALUE,
--   and subscript_vexpr evaluates to an integer or enum IVALUEs which
--   are the subscript values. The result is the selected component 
--   IVALUE.
-- 

      when "[]" => 
        [-, array, subscript_list] := evalexpr;
         while subscript_list /= [] loop
           subscript frome subscript_list;
           exec ( [["veval_", subscript],
                   ["veval_", ["$subscript"]] ]);
        end loop;
        exec( [["veval_", array]] );

      when "$subscript" => 
        pop( subscript );
        pop( array );
        [-, seq, lowval, highval] := array;

        if absent(lowval) or absent(highval) then
          system_error("$subscript");
        elseif lowval = uninitialized or highval = uninitialized then
          system_error("$subscript");
        elseif subscript < lowval or subscript > highval then
          exec([["raise", "CONSTRAINT_ERROR",
			"out-of-range subscript"]]);
        else
          value := seq (subscript - lowval + 1);
          if value = uninitialized 
             or (is_tuple(value) and value(2) = uninitialized) then
             exec([["raise", "PROGRAM_ERROR",
			"uninitialized element"]]);
          else
             push( value );
          end if;
        end if;
--S+ 4.1.2 Slices
--   ['[..]', array_vexpr, slice_texpr]
-- 
--   The array_vexpr is a VEXPR which evaluates to the array IVALUE.
--   The slice_texpr entry is a TEXPR which evaluates to an ITYPE for
--   discrete type whose range specifies the slice to be taken. If 
--   slice_texpr is a constraint operation, then it must be an 
--   'index_range' constraint.
-- 

      when "[..]" => 
        [-, array, slice] := evalexpr;
        exec ( [["veval_", array],
                ["teval_", slice],
                ["veval_", ["$slice"]]] );

      when "$slice" => 
        pop( slice );
        pop( array );
        [-, seq, lowval, highval] := array;
        [-, slicelo, slicehi] := slice;

        if absent(lowval) or absent(highval) then

          system_error("$slice");

        elseif lowval = uninitialized or highval = uninitialized then

          system_error("$slice");

        elseif slicehi < slicelo then -- null slice(special bounds check)
                                      -- RM 4.1.2 para. 2, 3
          push( ["array_ivalue", [], slicelo, slicehi] );

        elseif slicelo < lowval or highval < slicehi then

          exec ( [["raise", "CONSTRAINT_ERROR", "out-of-bounds"]]);

        else

          push( ["array_ivalue", 
            seq(slicelo - lowval + 1 .. slicehi - lowval + 1),
						    slicelo, slicehi] );

        end if;
--S+ 4.1.3 Selected Components (record)
--   ['.', record_vexpr, fieldname]
-- 
--   The record_vexpr is a VEXPR which evaluates to the record IVALUE.
--   The fieldname is the name (a SETL string) of the field whose 
--   corresponding IOBJECT will be the returned result. Note that we must
--   check for the field actually existing (may have wrong variant 
--   present).

      when "." => 
        [-, record_vexpr, fieldname] := evalexpr;
        exec ( [["veval_", record_vexpr],
                ["veval_", ["$select", fieldname]] ]);

      when "$select" => 
        [-, fieldname] := evalexpr;
        pop( record );
        [-, objdeclist] := record;
        if present(objdeclist(fieldname)) then

          fields := objdeclist("fields_present");
          if present(fields) then 
					-- record with 
                                        -- unconstrained variants
            if fieldname notin fields then         
              exec([["raise", "CONSTRAINT_ERROR", "field absent"]]);
            else
              value := objdeclist(fieldname);
            end if;

          else -- no variants or constrained discriminants

            value := objdeclist(fieldname);

          end if;

        else -- fieldname absent from this object

          exec( [["raise", "CONSTRAINT_ERROR", "field absent"]] );

        end if;
        if value = uninitialized 
           or (is_tuple(value) and value(2) = uninitialized) then
           exec([["raise", "PROGRAM_ERROR", "uninitialized field"]]);
        else
           push( value );
        end if;
--S+ 4.1.3 Selected components (dereference)
--   ['@', access_vexpr]
-- 
--   The access_vexpr entry is a VEXPR which when evaluated returns
--   an IVALUE of access type (or of a renamed object). The result 
--   returned is the IVALUE designated by the access value.
--
        when "@" => 
          [-, name] := evalexpr;
          exec( [["veval_", name],
                 ["veval_", ["$@"]]] );
        when "$@" => 
          pop( access_value );
          if is_access_ivalue(access_value) then 
             [-, iobject] := access_value;
             if iobject /= null_ then
                value := i_value( iobject );
                if value = uninitialized 
                   or is_uninitialized (value) then
                   exec( [["raise", "PROGRAM_ERROR",
                           "access to uninitialized object"]] );
                else
                   push( value );
                end if;
             else
                exec( [["raise", "CONSTRAINT_ERROR", "null access"]] );
            end if;
          else
             system_error("veval (dereferencing)");
          end if;
--S+ 4.3.1 Record aggregate
--       ['record_aggregate', type_name, 
--                           [field_name, element_vexpr], ....]
-- 
--       The field_names are the names of the corresponding fields,
--       and the range elements are VEXPR's for the field values.
--	Note that others cannot appear
--       explicitly, the front end is expected to expand others as
--       a list of the corresponding field names.
--
      when "record_aggregate" => 
         [-, type_name, field_list] := evalexpr;
         [-, -, -, discr_list] := get_itype(type_name);
         discr_list ?:= {};
         discr_exec := field_exec := [];

-- the discriminants are evaluated first, in case they are to
-- determine the constraint applicable to some of the components
-- cf. LRM 4.3.1(2)  4.3.2(9)
-- To achieve this, the field_list given is first sorted:

          for [field_name, field_vexpr] in field_list loop
               if field_name in discr_list then
                  discr_exec with:= [field_name, field_vexpr];
               else
                  field_exec with:= [field_name, field_vexpr];
               end if;
         end loop;

         exec([["veval_",
                ["$$record_aggregate", type_name, #field_exec]]]);
          for [field_name, field_vexpr] in field_exec loop
             exec( [["veval_", field_vexpr], ["push_", field_name]] );
         end loop;

         if discr_exec /= [] then
            exec([["veval_", ["$record_aggregate", #discr_exec]]]);
             for [field_name, field_vexpr] in discr_exec loop
              exec( [["veval_", field_vexpr], ["push_", field_name]] );
            end loop;
         end if;

     when "$record_aggregate" => 
       [-, nb_discr] := evalexpr;
       discr_map := {};
        for i in [1..nb_discr] loop   
           pop( discr_name );
           pop( discr_value );
           discr_map(discr_name) := discr_value; 
           -- to make them available for index subtype of other components:
           emap(discr_name) := discr_value;   
       end loop;
       push ( discr_map );

--
      when "$$record_aggregate" => 
         [-, type_name, num_field_values] := evalexpr;

         itype := get_itype(type_name); 
         disc_list := itype(4) ? {};	-- And its discrims

         field_map := {};		-- Construct the field map
          for i in [1..num_field_values] loop 
             pop( field_name );
             pop( field_value );
             field_map(field_name) := field_value;
         end loop;

         if nonempty(disc_list) then   -- Check if constrained
           pop ( discr_map );
           field_map +:= discr_map;
           itype := apply_discr(discr_map, itype);--Now it is constrained
        end if;

        push( ["record_ivalue", field_map] );

--S+ 4.3.2 Array aggregate 
--       ['array_aggregate', texpr, pos_entries, named_entries, ghost]
-- 
--       pos_entries    ::=   [vexpr, vexpr, ...] | []
--       named_entries  ::=   [[choice_list, element_vexpr], ...] | []
--       choice_list    ::=   'others' | [choice, ...]
--       choice         ::=   choice_vexpr | ['range', lbd, ubd]
-- 
--       The second component is a texpr for index constraint on the
--       value of the aggregate. This is used for assigning index
--       values to positional entries and for determining the values
--       supplied by an others clause.
-- 
--       The pos_entries component is a sequence of VEXPR's which give
--       values of the positional entries given, in the sequence in 
--       which they appear in the aggregate.
-- 
--       The named_entries component maps sets of index values, specified
--       by a choice_list entry, to corresponding values, as given by
--       the VEXPR element_vexpr. A choice_list entry has two forms,
--       it is either the string 'others', or it is a set of index
--       choices, where an index choice is either a VEXPR giving a
--       particular index value, or a TEXPR for a discrete type whose
--       bounds specify a range of index values.
--
--       The LRM 4.3.2(10) specify the following order of elaboration:
--         - first all the choices (including choices in subaggregates)
--         - if not a null array, check that the bounds of choices
--           belong to the index subtype (constraint_error)
--         - in all cases, if multidimensional array, check that all
--           subaggregates have same bounds (constraint_error)
--         - evaluate component expressions exactly as many times as
--           required by the choices


--  1.1 compute choices:

when "array_aggregate" => 
   [-, index_type_list, pos_entries, named_entries] := evalexpr;
   [exec_list, new_aggr] :=
     aggr_step_1_1(pos_entries, named_entries, index_type_list);
   exec( exec_list with
           ["veval_", ["$array_aggregate", index_type_list, new_aggr]]);

--  1.2 compute size of array, and check that bounds of subaggregates
--      are identical:

when "$array_aggregate" => 
   [-, index_type_list, [pos_entries, named_entries]] := evalexpr;
   [array_size, actual_index_list, c_error] :=
      aggr_step_1_2(pos_entries, named_entries, index_type_list);   
   if c_error then
      exec([["raise", "CONSTRAINT_ERROR", "incompatible bounds"]]);
      return; -- from VEVAL_PROC
   end if;

--  1.3 if not a null array, then check that bounds of (sub)aggregates 
--      belong to the index_subtype:
--      Note: we already know that all subaggregates have same bounds.
-- If the aggregate is an array constrained by discriminants, then
-- there are three bounds to consider: those of the discriminant subtype,
-- those given by the current discriminant, and those given by the aggregate
-- itself. We check here that the last two are compatible with the first.

   if array_size /= 0 then
       for i in [1..#index_type_list] loop

         [-, aggr_low, aggr_high] := actual_index_list(i);
         [-, type_low, type_high] := get_itype(index_type_list(i));
         if is_discr_ref(type_low) then
            [-, d_name, -, index_subtype] := type_low;
	    bound_low := get_itype(index_subtype)(2);
            type_low := emap(d_name) ? bound_low;
	    if type_low < bound_low then
		-- current value of discriminant is out of range
		exec([["raise", "CONSTRAINT_ERROR", 
			"bounds out of range (1)"]]);
		return; -- from VEVAL_PROC
	    end if;

         end if;
         if is_discr_ref(type_high) then
            [-, d_name, -, index_subtype] := type_high;
	    bound_high := get_itype(index_subtype)(3);
	    type_high := emap(d_name) ? bound_high ;
	    if type_high > bound_high then
		-- current value of discriminant is out of range
		exec([["raise", "CONSTRAINT_ERROR", 
			"bounds out of range (2)"]]);
		return; -- from VEVAL_PROC
	    end if;
         end if;

         
         -- note: we know that aggr_low <= aggr_high
         --        otherwise size would have been 0

         if aggr_low  < type_low
         or aggr_high > type_high then
	   int_trace("aggr_low =", str(aggr_low));
	   int_trace("aggr_high =", str(aggr_high));
	   int_trace("type_low =",  str(type_low));
	   int_trace("type_high =", str(type_high));
           exec([["raise", "CONSTRAINT_ERROR", 
		"bounds out of range (3)"]]);
           return; -- from VEVAL_PROC
         end if;
      end loop;

--  2.1 if null array, no evaluation of any component, we just build
--      an appropriate 'array_ivalue', with proper bounds:

   else  -- array_size = 0
      aggr := om;
       while actual_index_list /= [] loop
          [-, low, high] frome actual_index_list;
          aggr := ["array_ivalue", [aggr], low, high];
      end loop;
      push (aggr with "null");
      return; -- from VEVAL_PROC
   end if;

--  2.2 now compute all elements:

   exec([["veval_", ["$$array_aggregate", actual_index_list]]]);
   aggr_step_2_2(pos_entries, named_entries, actual_index_list);

--  2.3 gather components to build array_ivalue:

when "$$array_aggregate" => 
   [-, actual_index_list] := evalexpr;   
   aggr := aggr_step_2_3(actual_index_list);
   push ( aggr );

--S+ 4.4 Attribute
--      ['''', attribute, .....]
--
--      This form handles attributes. The bulk of the processing
--      is done in proc ATTRIBUTE_EVAL (q.v.).
--
       when "'" => 
         attribute_eval(evalexpr);
--S+ 4.5 Operators
--     ['andthen', op1, op2]
--
--     The andthen form takes two parameters which are the boolean
--     expressions for the operands. This case is handled specially  
--     because of the short circuit evaluation required.
--
      when "andthen" => 
        [-, op1, op2] := evalexpr;
        exec( [["veval_", op1],
               ["if_", [["veval_", op2]],
 		      [["push_", boolean_false ]]] ]);
--
--     ['in', exprv, type_expr]
--
--     Membership operator. The first parameter is 
--     the expression whose value is to be tested, and the second is 
--     an expression for the type.
--
      when "in" => 
--
         [-, exprv, type_expr] := evalexpr;
         exec( [["veval_", exprv],
                ["teval_", type_expr],
                ["veval_", ["$in"]] ]);
--
       when "$in" => 
         pop( typeentry );
         pop( value );
	 if is_discr_ref(value) then
		[-, d_name, -, index_subtype] := value;
		value := emap(d_name) ?
				 get_itype(index_subtype)(2);
	 end if;
         case typeentry.type_mark 

         when "integer", "enum" => 
           [-, lbd, ubd] := typeentry;
           push( test(value >= lbd and value <= ubd) );

         when "float" => 
           [-, lbd, ubd, -] := typeentry;
           push( test(  float_leq(lbd, value) and 
			float_leq(value, ubd)) );

         when "fixed" => 
           [-, lbd, ubd, -, -] := typeentry;
           push( test(fix_leq(lbd, value) and fix_leq(value, ubd)) );

         when "array" => 
           result := true;
           [-, index_list, element_itype, is_constrained] 
							:= typeentry;
            for index_itype in index_list loop
             [-, t_lval, t_uval] := get_itype(index_itype); 
             [-, lseq, o_lval, o_uval] := value;

 	   -- Now perform the bounds check. If the array type is unconstrained, 
	   -- the value must  be within the  given bounds. If constrained, the 
	   -- bounds of value and type must be the same.
	   -- The same rules apply to null arrays. (See C45265a)

             if (if is_constrained then		
                  (t_uval /= o_uval or t_lval /= o_lval) 
                 else				
                  (o_uval > t_uval or o_lval < t_lval) 
                 end if) then
                result := false;		-- mismatch.
                exit;
             end if;

             value := lseq(1) ;    -- check bounds of subarrays.
           end loop;
           push( test( result ) );

         when "record" => 
            [-, objdeclist] := value;
            [-, component_list, constr_disc_list] := typeentry;
            [types_objdec_list, -] := component_list;
            result := true;
            if present(constr_disc_list) then
              if exists f in constr_disc_list, 
			[d, [t, v]] in types_objdec_list | 
                   	      d = f and objdeclist(f) /= v(2) then
                result := false;
              end if;
            end if;
            push( test( result ) );
--
          when "access" => 
            [-, iobject] := value ;
	    if iobject = null_ then
	      push(test(true)) ;
            else
              [-, designated_type, -] := typeentry;
              push( value );   			-- to dereference it. 
              exec([
                 ["veval_", ["$@"]],		-- dereference.
                 ["teval_", designated_type],
                 ["veval_", ["$in"]]] ) ;	-- and recurse.
            end if;
-- 	All other cases
--
         otherwise =>
            push( test( true ) );
         end case;
--
--
--      ['notin', exprv, type_expr]
--
--      The notin form is  used for a notin  operator. The first 
--      parameter is the expression whose value is to be tested, and 
--      the second is an expression for the type.
--
       when "notin" => 
         [-, exprv, type_expr] := evalexpr;
         exec( [["veval_", ["not", ["in", exprv, type_expr]]]]);
--
--      ['orelse', op1, op2]
--
--      The orelse form takes two parameters which are the boolean
--      expressions for the operands. This case is handled specially 
--      because of the short circuit evaluation required.
--
       when "orelse" => 
         [-, op1, op2] := evalexpr;
         exec( [["veval_", op1],
                ["if_", [["push_", boolean_true]],
                       [["veval_", op2]]]] );
--
--S+ 4.6 Conversions
--      ['convert', from_type, to_type, cexpr]
--
--      Convert is used for those scalar type conversions in the source
--      that do not resolve to a range qualification check between
--      subtypes. In those cases where a conversion from one numeric
--      type to another is wanted, this operator must be used. This 
--      operator also emits a range check of the result against the 
--      target type.
--
    when "convert" => 
      [-, from_type, to_type, cexpr] := evalexpr;
      if from_type = to_type then
         exec( [["veval_", cexpr]] );
      else
         exec([["teval_", from_type],
               ["teval_", to_type],
               ["veval_", cexpr],
               ["veval_", ["$convert"]],
               ["veval_", ["qual_range_"]] ]);
      end if;
 
     when "$convert" => 
       pop( value );
       pop( to_type );
       pop( from_type );
       case from_type.type_mark 
       
         when "enum" => 
           case to_type.type_mark 
             when "enum" => 
                push( value );
           otherwise =>
             system_error("convert");
           end case;

         when "integer" => 
           case to_type.type_mark 
      
             when "integer" => 
               push( value );
    
             when "float" => 
               if (r_value := 
			float_fra([value,1],
				to_type.i_type_precision))
                  = "OVERFLOW" then
                 exec( [["raise", "CONSTRAINT_ERROR", "overflow"]] );
               else
                  push(r_value);
               end if;

             when "fixed" => 
               push(fix_fri(value,to_type.i_type_precision));
 
             otherwise =>
               system_error("convert");
 
           end case;
 
         when "float" => 
           case to_type.type_mark 
 
             when "integer" => 
               if (ivalue :=float_toi(value)) > ada_max_integer then
                 exec( [["raise", "CONSTRAINT_ERROR", "overflow"]] );
               else
                 push( ivalue );
               end if;
 
             when "float" => 
               if (r_value := float_convert(value,
                   			to_type.i_type_precision))
                  = "OVERFLOW" then
                 exec( [["raise", "CONSTRAINT_ERROR", "overflow"]] );
               else
                  push(r_value);
               end if;

             when "fixed" => 
               push(fix_ffl(value,to_type.i_type_precision));
 
             otherwise =>
               system_error("convert");
        
           end case;

         when "fixed" => 
           case to_type.type_mark 

             when "integer" => 
              if (ivalue := 
			fix_toi(value,from_type.i_type_precision)) > 
                  ada_max_integer then
                 exec( [["raise", "CONSTRAINT_ERROR", "overflow"]] );
               else
                 push( ivalue );
               end if;

             when "float" => 
               if (r_value := fix_tfl(value,from_type.i_type_precision,
                                      to_type.i_type_precision)) /=
                              "OVERFLOW" then
                 push( r_value );
               else
                 exec( [["raise", "CONSTRAINT_ERROR", "overflow"]] );
               end if;

             when "fixed" => 
               push( fix_convert(value, from_type.i_type_precision,
                                 to_type.i_type_precision) ) ;

             otherwise =>
               system_error("convert");

             end case;
	when "array" => 
	     convert_array(value, from_type, to_type) ;
         otherwise => 
 	     -- Other conversions between types derived from a common root
	     -- are no-ops.
             push(value) ;
 
       end case;
       push( to_type ); -- needed by 'qual_range_'
--S+ 4.7 Qualifiers
--     ['qual_range', typename, value]
--
--     The  qual_range form is used to check the value of an expression 
--     for inclusion in a scalar subtype. The first parameter is the name
--     of the type, and the second is the expression to be  qualified. 
--     Qual_range performs a range check appropriate to the type. Note 
--     that the intermediate language requires all range checks to be 
--     explicit. Thus the result of most operators must be appropriately
--     qualified using this form.
--
--
      when "qual_range" =>  
        [-, typename, value] := evalexpr;
--     In case of a qual_range enclosing a discr_ref, the evaluation is 
--     delayed, as it is evaluated only when building an object.

        if is_discr_ref(value) then
  	   -- If building an object, retrieve current value of discriminant.
           [-, discr_name] := value ;
	   value := emap(discr_name) ? value ;
           if is_discr_ref(value) then
	       -- delay evaluation.
   	       push(value with typename) ;
           else
               push(value) ;
               exec( [["teval_", typename],
                     ["veval_", ["qual_range_"]]] );
           end if;
        else
           exec( [["veval_", value],
                  ["teval_", typename],
                  ["veval_", ["qual_range_"]]] );
        end if;
--
      when "qual_range_" => 
        pop( typedesc );
        value := top_valstack();
        [-, lbd, ubd, -] := typedesc ;	-- for all scalar types.
        case typedesc.type_mark 

	  when "integer", "enum", "range" =>  
             if value < lbd or value > ubd then
                    exec( [["raise", "CONSTRAINT_ERROR", 
			"out of range(integer)"]] );
             end if;

          when "fixed" =>  
	     if fix_lss(value, lbd) or fix_gtr(value, ubd) then 
		    exec( [["raise", "CONSTRAINT_ERROR", 
			"out of range(fixed)"]] );
	     end if;

	  when "float" =>  
	     if float_lss(value, lbd) or float_gtr(value, ubd) then
	            exec( [["raise", "CONSTRAINT_ERROR", 
			"out of range(float)"]] );
	     end if;
	end case;		
--
--     ['qual_length', typename, value]
--
--     The  qual_length form is used to check the length of an array
--     for conformity to the length specified by an array type.The first
--     parameter is the name of the type, and the second is an expression
--     for the array to be qualified. 
--
      when "qual_length" => 
        [-, typename, value] := evalexpr;
        exec( [["veval_", value],
               ["teval_", typename],
               ["veval_", ["qual_length_"]]] );

--
      when "qual_length_" => 
        pop( itype );
        [-, index_list, -] := itype;
        array := [top_valstack()]; 
         while index_list /= [] loop
         index fromb index_list;

        [-, l_val, u_val] := get_itype(index); 
        [-, array, lbval, ubval, nullval] := array(1);
        nullval := present(nullval) or (ubval < lbval);
-- At this time we cannot handle bounds given by a discriminant

        if not (is_discr_ref(l_val) or is_discr_ref(u_val)) then 

 -- Now we perform the length check. Note that an empty array
 -- matches any empty array object, regardless of its bounds.

          if nullval and (u_val < l_val) then
             exit;  -- both empty
          elseif                                   --  not both empty
              u_val - l_val /= ubval - lbval	   --  not same length
          then
            exec( [["raise", "CONSTRAINT_ERROR", "not same length"]] );
          end if;
  
        end if;
      end loop;

--
--     ['qual_discr', typename, value]
--
--     The  qual_discr form is used to check a record for conformity to 
--     the discriminants specified by a record type. The first parameter 
--     is the name of the type, and the second is an expression for the 
--     record to be qualified. 
--
      when "qual_discr" => 
        [-, typename, value] := evalexpr;
        exec( [["veval_", value],
               ["teval_", typename],
               ["veval_", ["qual_discr_"]]] );
--
      when "qual_discr_" => 
        pop( itype );
        ivalue := top_valstack();
        [-, objdeclist] := ivalue;
        [-, component_list, constr_disc_list] := itype;

        if is_set(constr_disc_list) then 
--  Constrained record type, ensure that record value 
--  has same values for   discriminants.
          [types_objdec_list, -] := component_list;

          if exists f in constr_disc_list, 
		[d, [t, v]] in types_objdec_list | 
               	      d = f and objdeclist(f) /= v(2) then
              exec( [["raise", "CONSTRAINT_ERROR", "discriminant"]] );
          end if;

        end if;

--
--     ['qual_index', typename, value]
--
--     The  qual_index form is used to check a record for sliding array 
--     assignments in the initialization.  The first parameter is the
--     name of the type, and the second is an expression.
--
      when "qual_index" => 
        [-, typename, value] := evalexpr;
        exec( [["veval_", value],
               ["teval_", typename],
               ["veval_", ["qual_index_"]]] );
--
      when "qual_index_" => 
        pop( itype );
        ivalue := [top_valstack()];
        [-, index_list, element_itype] := itype;
         while index_list /= [] loop
           index_itype fromb index_list;
	   [-, l_val, u_val] := get_itype(index_itype);
	   [-, ivalue, lbval, ubval] := ivalue(1);
-- Note : NO, the fact that it may be a null array is irrelevant,
--        the subtypes of null arrays must be identical ! PK 21-Feb-84.
--
           if is_discr_ref(l_val) then
              [-, d_name, d_type] := l_val;
              l_val := emap(d_name) ? get_itype(d_type)(2);
           end if;
           if is_discr_ref(u_val) then
              [-, d_name, d_type] := u_val;
              u_val := emap(d_name) ? get_itype(d_type)(3);
           end if;
           if (u_val /= ubval or l_val /= lbval) then -- not same bounds
             exec( [["raise", "CONSTRAINT_ERROR", "not same bounds"]] );
             exit;
	   end if;
           -- In our representation, null arrays do not carry information about
           -- their possible subarrays. Thus (2..1 => (1..5 => 1)) is stored
           -- as a one-dimensional null array, and the bounds 1..5 are lost.
           -- This is likely a deficiency. An implementation with dope vectors
           -- would not necessarily have this problem.
           if ivalue = [] then 
              exit; 
           end if; 
	end loop;
--
--  [ 'qual_access', type_name, access_vexpr, actual_qual ]
--
--    This form is used to check the value designated by an access
--    value. After dereferencing the value, it transfers control to
--    one of the actual 'qual' sub-instruction : 'qual_index_', 
--    'qual_length_', 'qual_discr_' or 'qual_range_'.
--    typename is the subtype, and access_vexpr designates the value
--    to qualify.
--
    when "qual_access" => 
       [-, type_name, access_vexpr, actual_qual ] := evalexpr;
       exec( [["veval_", access_vexpr],
              ["veval_", ["qual_access_", type_name, actual_qual]]] );
--
    when "qual_access_" => 
       [-, type_name, actual_qual] := evalexpr;
       ivalue := top_valstack();
       [-, iobject] := ivalue;
       if iobject /= null_ then
           push( ivalue );   -- duplicate TOS
           exec([
                 ["veval_", ["$@"]],
                 ["teval_", type_name],
                 ["veval_", [actual_qual]],
                 ["pop_"]                  ]);-- discard TOS
       end if;

--
--   [ 'qual_sub', index_list, array_vexpr ]
--
--    This form is used to qualify the index ranges of an array value,
--    given by array_vexpr, by a subtype, namely texpr.
--    The array_ivalue is left on top of stack.
--
   when "qual_sub" => 
      [-, index_list, array_expr] := evalexpr;
      exec ( [["veval_", array_expr],
              ["push_", index_list],
              ["veval_", ["qual_sub_"]]] );
--
   when "qual_sub_" => 
      pop ( index_list );
      array := [top_valstack()]; 
       while index_list /= [] loop
         index fromb index_list;
         [-, lowb, highb] := get_itype(index);
         [-, array, low, high, nullval] := array(1);
         nullval := present(nullval) or (high < low);
         if nullval then 
            exit; 
         end if;
         if ( low < lowb ) or ( high > highb ) then
            exec( [["raise", "CONSTRAINT_ERROR", "out of bounds"]]);
         end if;
      end loop;
--
--     Qualifications on access types are also produced in the front end
--     and are converted here to the generic qual_access.

      when "qual_adiscr", "qual_aindex", "qual_alength", "qual_arange" => 
       [opc, type_name, access_vexpr] := evalexpr;
       actual_qual := "qual_" + opc(7..) + "_";

       exec( [["veval_", access_vexpr],
              ["veval_", ["qual_access_", type_name, actual_qual]] ]);
--S+ 4.8 Allocators
--     ['new', type_name, object_texpr, aexpr]
--
--     The 'new' operation executes an allocator. Type_name is
--     the access type.
--     Object_texpr is a texpr giving the  designated type, and aexpr,
--     when  present, is a vexpr for the value of the designated object. 
--
      when "new" => 
	[-, type_name, object_texpr, aexpr] := evalexpr;

        if present(aexpr) and aexpr /= [] then
          exec( [["teval_", object_texpr],
                 ["veval_", aexpr], 
		 ["veval_", ["new_1"]] ]);
	else
	    obj_type := if is_simple_name(object_texpr) then
					object_texpr else "" end if;
	    exec([["teval_", object_texpr],
 	          ["veval_", ["new_", type_name, obj_type]] ]);
	end if;

      when "new_" => 
        -- Complete execution of allocator with a  subtype indication.
        [-, type_name, obj_type] := evalexpr;
	[-, -, t_master, t_taskenv] :=
                  emap(type_name) ? global_emap(type_name);
        pop( object_type );

        if object_type.type_mark = "record" then
           [-, -, constr_discr_list, discr_list] := object_type;
           object_type(3) := constr_discr_list ? discr_list;
        end if;

        push( tasks_declared );
        tasks_declared := {};
        exec ([
            ["create_obj_", object_type, true, t_master, t_taskenv,
               obj_type],
            ["activate_"],
            ["veval_", ["new_2"]] ]);

--
      when "new_1" => 
        -- Complete execution of allocator with initial value.
        pop( value );
        pop( object_itype );
	if object_itype.type_mark = "record" 
	  and #(disc_list := object_itype(4)) = 0 then
	    -- create an object and assign aggregate to it. The object does
	    -- not contain tasks, because an aggregate does not have limited
	    -- components. It is necessary to create the object first in the
	    -- case in which some component is an unconstrained record. If
	    -- instead we just copied the aggregate, the component would appear
	    -- incorrectly to be constrained. (C45272A)
	    -- This special case can be limited to unconstrained types with
	    -- unconstrained components. We do it here for all records without
	    -- discriminants. 
            exec ([
             ["create_obj_", object_itype, false, curtask, height(curtask), ""],
             ["veval_", ["new_3", value]] ]);
        else
            new_loc := create_copy(value, object_itype, om);
            push( ["access_ivalue", new_loc] );
	end if;

      when "new_2" => 
        -- After allocator is  constructed, and tasks have been activated,
        -- restore environment. 
        pop( new_loc );
        pop( tasks_declared );
        push( ["access_ivalue", new_loc] );

       when "new_3" => 
        --  After creating object for designated record object, assign
        -- aggregate to it.
        [-, value] := evalexpr ;
        pop(object) ;
        setval(object, value , om) ;
        push(["access_ivalue", object]);

--S+ call and raise
--     ['call', ..... ]
--
--     The call form is used for a call to a function within an 
--     expression. It is identical to a normal call statement (q.v.),
--     and is pushed onto the main statement sequence for execution.
--
      when "call" => 
        exec( [evalexpr] );
--
--     ['raise', exception_name]
--
--     An exception may be raised within an expression by use of this
--     form. The raise is simply pushed onto the statement sequence.
--
      when "raise" => 
        exec( [evalexpr] );
--S+ others operators (4.5)
-- Remaining forms are operator forms where the first element is the
-- operator name. In the case of a binary operator, there are two
-- parameters which are the expressions for the left and right operands.
-- In the unary case, there is a single parameter which is the
-- expression for the operand. The arguments to these forms are evaluated
-- and an opbinary_ or opunary_ statement is pushed onto STM as needed.
--
      otherwise =>
        [opname, op1, op2, type1, type2, result_type] :=
        evalexpr;

        if opname in unary_ops then
          exec( [["veval_", op1],
                 ["opunary_", opname] ]);
        elseif opname in fix_ops then
          exec( [["veval_", op1],
                 ["veval_", op2],
                 ["teval_", type1],
                 ["teval_", type2],
                 ["teval_", result_type],
                 ["opfix_", opname] ]);
        else 
          exec( [["veval_", op1],
                 ["veval_", op2],
                 ["opbinary_", opname] ]);
        end if;

      end case;
end veval_proc;
procedure get_value(x);
   return if is_integer(x) then x
   elseif x(1) = "ivalue" then x(2)
   else "error in aggr 1.1"
   end if;
end get_value;
--T+ OPERATORS
--S+ OPFIX
procedure opfix(opname);
--
-- OPFIX( opname)
-- --------------
--
-- Operations evalutated by OPFIX are:
--
    pop( type3);
    pop( type2);
    pop( type1);
    pop( op2 );
    pop( op1 );
    if absent(op1) or absent(op2) or absent(type1) or absent(type2)
     or absent(type3) then
      system_error("opfix");
      return;
    end if;
    case opname 

-- '*fx' fixed point multiplication  

      when "*fx" => 
         case type3.type_mark 
          when "fixed" => 
              push( fix_mul_tfi(op1, op2, type1.i_type_precision,
                    type2.i_type_precision, type3.i_type_precision));
          when "float" => 
              push( fix_mul_tfl(op1, op2, type1.i_type_precision,
                    type2.i_type_precision, type3.i_type_precision));
          when "integer" => 
              push( fix_mul_toi(op1, op2, type1.i_type_precision,
                    type2.i_type_precision));
          end case;


-- '/fx' fixed point division

      when "/fx" => 
         if fix_eql(op2, fix_0) then
            exec( [["raise" , "CONSTRAINT_ERROR", "divide by zero"] ]);
         else
            case type3.type_mark 
             when "fixed" => 
                 push( fix_div_tfi(op1, op2, type1.i_type_precision,
                  type2.i_type_precision, type3.i_type_precision));
             when "float" => 
                 push( fix_div_tfl(op1, op2, type1.i_type_precision,
                  type2.i_type_precision, type3.i_type_precision));
             when "integer" => 
                 push( fix_div_toi(op1, op2, type1.i_type_precision,
                       type2.i_type_precision));
             end case;
         end if;

     otherwise =>
    system_error("attempt to evaluate some unknown fixed type operator"
                       + str(opname) );

   end case;
--
--
--
end opfix;

procedure check_for_overflow;
    case type(valstack(#valstack)) 
      when "INTEGER","integer" => 
        if abs(valstack(#valstack)) > ada_max_integer then
          exec([["raise", "CONSTRAINT_ERROR", "integer overflow"]]);
        end if;
      otherwise =>
        system_error("check_for_overflow");
    end case;
end check_for_overflow;
--S+ OPBINARY
procedure opbinary(opname);
--
-- OPBINARY( opname)
-- -----------------
--
--  Evaluates binary operator opname. The operands are assumed to have
--  been evaluated onto VALSTACK. This is the lowest level of the 
--  evaluation process for arithmetic expressions by 'veval_' .
--

--
-- Operations evalutated by OPBINARY are:
--
    pop( op2 );
    pop( op1 );
    if absent(op1) or absent(op2) then
      system_error("opbinary");
      return;
    end if;
    case opname 
 

-- '+i'    integer addition

      when "+i" => 
        push( op1 + op2 );
        check_for_overflow;
 

-- '+fl'   floating addition

      when "+fl" => 
        if ((r_value := float_add(op1, op2)) = "OVERFLOW") then
          exec([["raise", "CONSTRAINT_ERROR", "float overflow in +"]]);
        else
           push( r_value );
        end if;

-- '+fx'   fixed addition
 
      when "+fx" => 
        push( fix_add(op1, op2) );

-- '-i'    integer subtraction

      when "-i" => 
        push( op1 - op2 );
        check_for_overflow;
 
-- '-fl'   floating subtraction

      when "-fl" => 
        if ((r_value := float_sub(op1, op2)) = "OVERFLOW") then
          exec([["raise", "CONSTRAINT_ERROR", "float overflow in -"]]);
        else
           push( r_value );
        end if;

-- '-fx'   fixed subtraction

      when "-fx" => 
        push( fix_sub(op1, op2) );

-- '*i'    integer multiplication

       when "*i" => 
         sign_result := (sign(op1) ) * (sign(op2) );
         if sign_result = 0 then
           push( 0 );
         else
           [op1, op2] := [abs(op1) , abs(op2) ];
           if (op1 < ada_max_integer_sqrt)
                and (op2 < ada_max_integer_sqrt) then
             push( sign_result * op1 * op2 );
           else
             [a, b] := [op1 / ada_max_integer_sqrt,
                         op1 mod ada_max_integer_sqrt];
             [c, d] := [op2 / ada_max_integer_sqrt,
                         op2 mod ada_max_integer_sqrt];
             if a /= 0 and c /= 0 then
               exec( [["raise", "CONSTRAINT_ERROR", "overflow"]] );
             elseif (result := b*c + a*d) >= ada_max_integer_sqrt then
               exec([["raise", "CONSTRAINT_ERROR", "overflow"]]);
             else
               push( sign_result *
		    (result*ada_max_integer_sqrt + b*d) );
               check_for_overflow;
             end if;
           end if;
	 end if;

-- '*fl'   floating multiplication

      when "*fl" => 
        if (r_value := float_mul(op1, op2)) = "OVERFLOW" then
          exec([["raise", "CONSTRAINT_ERROR", "float overflow in *"]]);
        else
          push( r_value );
        end if;


-- '/i'   integer division
  
      when "/i" => 
        if op2 = 0 then
          exec( [["raise", "CONSTRAINT_ERROR", "divide by zero"]] );
        else
          push( op1 / op2 );
	  check_for_overflow;
        end if;

-- '/fl'  floating division
 
      when "/fl" => 
        if float_eql(op2, float_0) then
          exec( [["raise" , "CONSTRAINT_ERROR", "divide by zero"] ]);
        elseif (r_value := float_div(op1, op2)) = "OVERFLOW" then
          exec([["raise", "CONSTRAINT_ERROR", "overflow in /"]]);
        else
          push( r_value );
        end if;

-- '*fxi' multiply fixed by integer

     when "*fxi" => 
       push ( fixi_mul(op1, op2));

-- '*ifx' multiply integer by fixed

     when "*ifx" => 
       push ( fixi_mul(op2, op1) );

-- '/fxi' divide fixed by integer

     when "/fxi" => 
       if op2 = 0 then
          exec( [["raise", "CONSTRAINT_ERROR", "divide by zero"]] );
       else
          push ( fixi_div(op1, op2) );
       end if;
 
-- '*fli' multiply float by integer
     
     when "*fli" => 
        if ((r_value := floati_mul(op1, op2)) = "OVERFLOW") then
          exec([["raise", "CONSTRAINT_ERROR", 
						  "float overflow in *fli"]]);
        else
          push ( r_value );
	end if;
-- '/fli' divide float by integer
     
     when "/fli" => 
       if op2 = 0 then
          exec( [["raise", "CONSTRAINT_ERROR", "divide by zero"]] );
       else
          push ( floati_div(op1, op2) );
       end if;

-- '='   equality test
 
      when "=" => 
        push( test(equal_values(op1, op2)) );

-- '/='   inequality test
 
      when "/=" => 
        push( test(not equal_values(op1, op2)) );

-- '<'   less then test
 
      when "<" => 
        push( test(less_than_values(op1, op2)) );

-- '<='  less then or equal test
 
      when "<=" => 
        push(test(less_than_values(op1, op2) or
		  equal_values(op1, op2)));

-- '>'   greater then test
 
      when ">" => 
        push( test(less_than_values(op2, op1)) );

-- '>='  greater then or equal test
 
      when ">=" => 
        push(test(less_than_values(op2, op1) or
		  equal_values(op1, op2)));

-- '**i'  integer to integer power
     
       when "**i" => 
         if op2 < 0 then
           exec( [["raise", "CONSTRAINT_ERROR", "negative exp"]] );
         end if;
         if op1 >= 0 then
            sign_result := 1;
         else
            sign_result := if even (op2) then 1 else -1 end if;
            op1 := abs(op1) ;
         end if;
         result := 1;
          for i in [1..op2] loop
            result *:= op1;
            if result > ada_max_integer then
               exec([["raise", "CONSTRAINT_ERROR", "overflow"]]);
               exit;
            end if;
         end loop;
         push( sign_result * result );

-- '**fl' float to integer power
 
      when "**fl" => 
        if op1 = [0,[0],0] and op2 < 0 then
           exec( [["raise", "CONSTRAINT_ERROR", "divide by zero" ]] );
        elseif (r_value:= float_exp(op1,op2))= "OVERFLOW" then
           exec([["raise","CONSTRAINT_ERROR","float overflow **"]]);
        else
           push( r_value );
        end if;
--  array concatenation
-- If an operand is of the component type, we construct a one-component array
-- before performing array-array concatenation.
 
      when "&", "&ac", "&ca", "&cc" => 
        case opname 
            when "&ac" =>  op2 := ["array_ivalue", [op2], 1,1];
            when "&ca" =>  op1 := ["array_ivalue", [op1], 1,1];
            when "&cc" => 
	             op1 := ["array_ivalue", [op1], 1,1];
	             op2 := ["array_ivalue", [op2], 1,1];
            otherwise => null ;
        end case;

        [-, seq_op1, l_op1, u_op1] := op1;
        [-, seq_op2, l_op2, u_op2] := op2;
        len_op1 := if l_op1 <= u_op1 then u_op1 - l_op1 + 1
                  		     else 0 end if;

        len_op2 := if l_op2 <= u_op2 then u_op2 - l_op2 + 1
                   		     else 0 end if;

        if len_op1 = 0 then
           push( op2 );
        elseif len_op2 = 0 then
           push( op1 );
        else
           push(["array_ivalue", seq_op1 + seq_op2,
                 l_op1, l_op1 + len_op1 + len_op2 - 1 ]);
        end if;

-- 'and'  boolean conjunction. 

      when "and" => 
        if is_literal_ivalue(op1) then
          push( op1 min op2 );
        else
          [-, seq_op1, l_op1, u_op1] := op1;
          [-, seq_op2, -, -] := op2;
          if #seq_op1 /=  #seq_op2 then
	   exec([["raise", "CONSTRAINT_ERROR", "boolean arrays"]]) ;
	  else
           new_seq := [seq_op1(i) min seq_op2(i) : i in [1..#seq_op1]];
           push( ["array_ivalue", new_seq, l_op1, u_op1] );
	  end if;
        end if;

-- 'remi'  integer remainder 

      when "remi" => 
        if op2 = 0 then
          exec( [["raise", "CONSTRAINT_ERROR","modulo zero"]] );
        else
          push( op1 - (op1 / op2)*op2 );
          check_for_overflow; 
        end if;

-- 'modi'  integer modulus

      when "modi" => 
        if op2 = 0 then
          exec( [["raise", "CONSTRAINT_ERROR", "modulo zero"]] );
        else
	  m := op1 - ((op1 / op2) * op2);
	  if (sign (m) * sign(op2)) = -1 then 
	     m +:= op2;
	  end if;
	  push(m);
          check_for_overflow;
        end if;

-- 'or'  boolean or
 
      when "or" => 
        if is_literal_ivalue(op1) then
          push( op1 max op2 );
        else
          [-, seq_op1, l_op1, u_op1] := op1;
          [-, seq_op2, -, -] := op2;
          if #seq_op1 /=  #seq_op2 then
	      exec([["raise", "CONSTRAINT_ERROR", "boolean arrays"]]) ;
	  else
              new_seq := [seq_op1(i) max seq_op2(i) 
              				         : i in [1..#seq_op1]];
              push( ["array_ivalue", new_seq, l_op1, u_op1] );
	  end if;
        end if;

-- 'xor'  boolean exclusive or
 
      when "xor" => 
        if is_literal_ivalue(op1) then
          push( test(op1 /= op2) );
        else
          [-, seq_op1, l_op1, u_op1] := op1;
          [-, seq_op2, -, -] := op2;
          if #seq_op1 /=  #seq_op2 then
	      exec([["raise", "CONSTRAINT_ERROR", "boolean arrays"]]) ;
	  else
              new_seq := [test(seq_op1(i) /= seq_op2(i)) 
              				         : i in [1..#seq_op1]];
              push( ["array_ivalue", new_seq, l_op1, u_op1] );
	  end if;
        end if;
 
      otherwise =>
         system_error("attempt to evaluate unknown binary operator "
                      + str(opname) );
    end case;
--
--
--
end opbinary;
--S+ OPUNARY
procedure opunary(opname);
--
-- OPUNARY( opname)
-- ----------------
--
--  Evaluates unary operators for 'veval_' . The operand has been
--  evaluated onto VALSTACK.
--
--  Operators evaluated by OPUNARY are:
--
    pop( op1 );
    if absent(op1) then
      system_error("opunary");
      return;
    end if;
    case opname 

-- '+ui'  unary integer plus
-- '+ufl' unary float plus
-- '+ufx' unary fixed plus
 
      when "+ui", "+ufl", "+ufx" => 
        push( op1 );

-- '-ui'  unary integer minus
 
      when "-ui" => 
        push( -op1 );

-- '-ufl' unary float minus
 
      when "-ufl" => 
        push( float_umin(op1) );

-- '-ufx' unary fixed minus

      when "-ufx" => 
        push( fix_umin(op1) );   

-- 'not'  boolean not
 
      when "not" => 
        if is_literal_ivalue(op1) then
	  push( test(op1 = boolean_false) );
        else
          [-, seq_op1, l_op1, u_op1] := op1;
          new_seq := [test(seq_op1(i) = boolean_false)
                       : i in [1..u_op1 - l_op1 + 1]];
          push( ["array_ivalue", new_seq, l_op1, u_op1] );
        end if;

-- 'absi'  integer absolute value

      when "absi" => 
        push( abs(op1) );

-- 'absfl' float absolute value

      when "absfl" => 
        push( float_abs(op1) );

-- 'absfx' fixed absolute value

      when "absfx" => 
        push( fix_abs(op1) );


-- 'row' rows a scalar operand of &

      when "row" => 
        push( ["array_ivalue", [op1], 1, 1] );
 
      otherwise =>
         system_error("attempt to evaluate unknown unary operator "
                      + str(opname) );
    end case;
end opunary;
--S+ EQUAL_VALUES
procedure equal_values(op1, op2);
--
-- EQUAL_VALUES(op1, op2)
-- ---------------------
--
-- Used in comparison operators to test for equality of IVALUES.
-- (Setl = cannot be used because of definition of equality for
-- array and record values RM 4.5.2 para. 5 and 6.)
--
  if is_float_ivalue(op1) then
    return float_eql(op1, op2);
  elseif is_fixed_ivalue(op1) then
    return fix_eql(op1, op2);
  elseif is_array_ivalue(op1) then
    [-, seq1, l_op1, u_op1, null1] := op1;
    [-, seq2, l_op2, u_op2, null2] := op2;
    -- two null arrays are equal 4.5.2(5)
    if     ((null1 = "null") or (u_op1 < l_op1))
       and ((null2 = "null") or (u_op2 < l_op2)) then
      return true;
    elseif  u_op1 - l_op1 /= u_op2 - l_op2 then
      return false;
    else
      return (forall i in [1..u_op1 - l_op1 + 1] 
               | equal_values(seq1(i), seq2(i)) );
    end if;
  elseif is_record_ivalue(op1) then
    [-, r_map1] := op1;
    [-, r_map2] := op2;
    dr1 := domain r_map1;
    dr2 := domain r_map2;

    if "fields_present" in dr1 then
       dr1 := r_map1("fields_present");
    end if;
    if "fields_present" in dr2 then
       dr2 := r_map2("fields_present");
    end if;

    if dr1 /= dr2 then
      return false;

    else

      return (forall f_name in dr1
               | equal_values(r_map1(f_name), r_map2(f_name)) );

    end if;

  else -- other ivalues (in particular access values)
       -- can make do with Setl =
    return op1 = op2;
  end if;
end equal_values;
--S+ LESS_THAN_VALUES
procedure less_than_values(op1, op2);
int_trace("At proc LESS_THAN_VALUES ","op1 and op2 follow:");
int_trace(op1, op2);
--
-- LESS_THAN_VALUES(op1, op2)
-- -------------------------
-- Used in comparison operators to test for less than.
-- RM 4.5.2 requires test to be availiable only for discrete
-- values and one-dimensional arrays of discrete values.
--

  if is_literal_ivalue(op1) then
    int_trace(" is a literal","") ;
    return op1 < op2;
  elseif is_float_ivalue(op1) then
    int_trace(" is a float","") ;
    return float_lss(op1, op2);
  elseif is_fixed_ivalue(op1) then
    int_trace(" is a fixed","") ;
    return fix_lss(op1, op2);
  elseif is_array_ivalue(op1) then
    int_trace(" is an array ","") ;
    [-, seq1, l_op1, u_op1] := op1;
    [-, seq2, l_op2, u_op2] := op2;
    len1 := (u_op1 - l_op1 + 1) max 0;
    len2 := (u_op2 - l_op2 + 1) max 0;
     for i in [1 .. len1 min len2] loop
      if seq1(i) > seq2(i) then
        return false;
      elseif seq1(i) < seq2(i) then
	return true;
      end if;
    end loop;
    return len1 < len2;
  else
    system_error("LESS_THAN_VALUES");
  end if;
end less_than_values;    

--T+ Subsidiary procedures for array aggregate evaluation (4.3.2)
--S+ aggr 1.1: evaluate non static choices
procedure aggr_step_1_1(pos_entries, named_entries, index_type_list);
int_trace("At procedure aggr_step_1_1", "");
int_trace(pos_entries, named_entries);
int_trace(index_type_list,"");
--
--   Step 1.1 of array aggregate evaluation:
--     - evaluate all non static choices, building anonymous range 
--         subtype for each one;
--     - returns a tuple consisting of 
--         . the list of choices to evaluate
--         . a new aggregate, where the choices have been replaced
--           by the appropriate subtype.
--
--   Note: there are a few rules that restrict the possibilities:
--     - apart from a final 'others' choice, the rest of the aggregate
--       must be either all positional or all named
--     - a named association is only allowed to have a choice that is
--       not static (or a choice that is a null range) if the aggregate
--       includes a single component association, and this component
--       association has a single choice. 'others' is static if the
--       index subtype is static.


    exec_list := [];
    index_type fromb index_type_list;
    int_trace("index_type=",str(index_type)) ;

-- first try to find some non-static choice, and replace it by a subtype
-- name:

    if pos_entries = []
       and #named_entries = 1
    then
       [[choice_list, element_vexpr]] := named_entries;
       if choice_list = "others" then
          new_type := index_type;
       elseif is_simple_name(choice_list) then
          new_type := choice_list;
       elseif #choice_list = 1 then
          [choice] := choice_list;
          if is_range(choice) then
            actual_index := ["subtype", index_type, choice] ; 

          elseif choice(1) = "subtype" or choice(1) = "tname" then
             actual_index := choice;
          else
	    i_type := choice ? "INTEGER" ;
	    -- if the bounds are not static then i_type will be a
	    -- tuple representing an expression, in which case we get its type.
	    i_type := if is_tuple(i_type) then i_type(#i_type) 
					  else i_type end if;
             actual_index := 
                  ["subtype", i_type, ["range", choice, choice]];
          end if;
          new_type := "aggr_index" + str(newat_str());
          exec_list with := ["type", new_type, actual_index];
       else -- single choice list but more than one choice: then static
          new_type := index_type;
       end if;
       named_entries := [[ new_type, element_vexpr]];
   end if;


--   then, if we have not exhausted all dimensions, we (recursively) go
--   down one level
--   also do some clean up in the named part

   iteration := named_entries;
   named_entries := [];
    for [choice_list, element_vexpr] in iteration loop
      if is_simple_name(choice_list) then
         new_choice_list := choice_list;
      else
         new_choice_list := [];
          for choice in choice_list loop
            if is_range(choice) then
               [-, lbd, ubd] := choice;
            else
               lbd := ubd := choice;
            end if;
            new_choice_list with:= 
               ["range", get_value(lbd), get_value(ubd)];
         end loop;
      end if;
      if index_type_list /= [] then
         if element_vexpr(1) = "ivalue" then
            -- undo multidimensional array partially folded by front-end
            [-, seq, low, high, nullval] := element_vexpr(2); 
            p := n := [];
            if present(nullval) or high < low then
               n := [[[["range", low, high]], seq(1)]];
            else
               p := seq;
            end if;
         else	-- necessarily an array_aggregate
            [-, -, p, n] := element_vexpr;
         end if;
         [sub_exec_list, element_vexpr] :=
                 aggr_step_1_1(p, n, index_type_list);
         exec_list +:= sub_exec_list;
      end if;
      named_entries with:= [new_choice_list, element_vexpr];
   end loop;
   if index_type_list /= [] then
      iteration := pos_entries;
      pos_entries := [];
       for element_vexpr in iteration loop
         if element_vexpr(1) = "ivalue" then
            -- too hastily folded by front-end into an 'array_ivalue'
            p := element_vexpr(2)(2);
	    n := []; 
         else	-- necessarily an array_aggregate
            [-, -, p, n] := element_vexpr;
         end if;
          [sub_exec_list, sub_aggr] :=
			aggr_step_1_1(p, n, index_type_list);
          exec_list +:= sub_exec_list;
          pos_entries with:= sub_aggr;
      end loop;
   end if;

   return [exec_list, [pos_entries, named_entries]];
end aggr_step_1_1;
--S+ aggr 1.2: compute and check bounds
procedure aggr_step_1_2(pos_entries, named_entries, index_type_list);   
--
--   Step 1.2 of array aggregate evaluation:
--     - compute the actual structure of the aggregate
--     - checks that all subaggregate have the same bounds
--     - returns a triple consisting of:
--        . the size of the array
--        . the actual index type list
--        . a flag indicating a constraint_error

   index_type fromb index_type_list;

--  Go down recursively in the inner subaggregates (if any)

   if index_type_list /= [] then
      actual_index_list := om;
       for [choice_list, element_vexpr] in named_entries loop
          [p, n] := element_vexpr; -- necessarily an array_aggregate
          [sub_size, sub_index_list, c_error] := 
               aggr_step_1_2(p, n, index_type_list);
          actual_index_list ?:= sub_index_list; -- first occurence
          if c_error or (actual_index_list /= sub_index_list) then
             return [0, [], true];
          end if;
      end loop;
       for element_vexpr in pos_entries loop
          [p, n] := element_vexpr; -- necessarily an array_aggregate
          [sub_size, sub_index_list, c_error] := 
               aggr_step_1_2(p, n, index_type_list);
          actual_index_list ?:= sub_index_list; -- first occurence
          if c_error or (actual_index_list /= sub_index_list) then
             return [0, [], true];
          end if;
      end loop;
   else
      sub_size := 1;
      actual_index_list := [];
   end if;      

-- Now compute the structure of the present aggregate: the current
--   actual index has the form ['range', low, high]

   [-, low, high] := get_itype(index_type);
   if is_discr_ref(low) then
      [-, d_name, -, index_subtype] := low;
      low := emap(d_name) ? get_itype(index_subtype)(2);
   end if;
   if is_discr_ref(high) then
      [-, d_name, -, index_subtype] := high;
      high := emap(d_name) ? get_itype(index_subtype)(3);
   end if;
 
   if pos_entries /= [] then
      if named_entries = [] then 
         high := low - 1 + #pos_entries;
         -- else there must be an 'others' choice 
      end if;

-- only named entries:

   elseif named_entries /= [] then 

      -- detect the non static case (which is single choice)
      if #named_entries = 1
      and is_simple_name(n := named_entries(1)(1)) then
         [-, low, high] := get_itype(n);
         if is_discr_ref(low) then
            [-, d_name, -, index_subtype] := low;
            low := emap(d_name) ? get_itype(index_subtype)(2);
         end if;
         if is_discr_ref(high) then
            [-, d_name, -, index_subtype] := high;
            high := emap(d_name) ? get_itype(index_subtype)(3);
         end if;

      -- purely static, but may have an  'others' choice
      elseif exists [u, -] in named_entries | u = "others" then
         null; -- [-, low, high] := GET_ITYPE(index_type);

      -- purely static, no others choice
      else
         high := low := om;
          for [choice_list, -] in named_entries loop
             for choice in choice_list loop
               [-, lbd, ubd] := choice; -- only 'range' left
               high ?:= ubd;
               high max:= ubd;
               low ?:= lbd;
               low min:= lbd;
            end loop;
         end loop;
         present_index := ["range", low, high];
      end if;

-- no named entries and no positional entries : null string
   else
      if low = ada_min_integer then -- careful !
         low +:= 1;
      end if;
      high := low - 1;
   end if;

--  Now that we have the current index subtype and the size of a 
--  subaggregate, we can compute the size:
    size := sub_size * ( 0 max (high - low + 1) );
    actual_index_list := [["range", low, high]] + actual_index_list;

    return [size, actual_index_list, false];

end aggr_step_1_2;
--S+ aggr 2.2: evaluate components
procedure aggr_step_2_2(pos_entries, named_entries, actual_index_list);
--
--   Step 2.2 of array aggregate evaluation:
--     - evaluation of the components, actual_index_list being used
--       to determine how many are missing in the case of an 'others'
--       choice.

   [-, low, high] fromb actual_index_list;
   low_index := low;
   mapping := {};
    for element_vexpr in pos_entries loop
      mapping(low_index) := element_vexpr;
      low_index +:= 1;
   end loop;
    for [choice_list, element_vexpr] in named_entries loop
      if is_simple_name(choice_list) then 
        -- this covers both the non static range and the 'others' choice
          for i in [low_index..high]| absent(mapping(i)) loop
             mapping(i) := element_vexpr;
         end loop;
      else
          for choice in choice_list loop
            [-, lbd, ubd] := choice;
             for i in [lbd..ubd] loop
               mapping(i) := element_vexpr;
            end loop;
         end loop;
      end if;
   end loop;

--  exact sequence of evaluation:

   if actual_index_list = [] then
      exec( [["veval_", mapping(i)] : i in [low..high] ] );
   else
       for i in [low..high] loop
         [p, n] := mapping(i);
         aggr_step_2_2(p, n, actual_index_list);
      end loop;
   end if;

end aggr_step_2_2;
--S+ aggr 2.3: build array_ivalue
procedure aggr_step_2_3(actual_index_list);
--   
--   Step 2.3 of array aggregate evaluation:
--     - build and return the array_ivalue whose structure is given
--       by the actual index list and whose components are on the
--       stack

   [-, low, high] fromb actual_index_list;
   if actual_index_list /= [] then
      aggr := [];
       for i in [low..high] loop
         aggr with:= aggr_step_2_3(actual_index_list);
      end loop;
   else
      aggr := valstack(#valstack - high + low ..);
      valstack(#valstack - high + low ..) := [];
   end if;
   return ["array_ivalue", aggr, low, high];

end aggr_step_2_3;

procedure sign(x);
case
  when is_integer(x) =>
     case
        when (x<0) => return -1;
        when (x=0) => return 0;
        when (x>0) => return 1;
     end case;
  when is_real(x) =>
     case of
        when (x<0.0) => return -1;
        when (x=0.0) => return 0;
        when (x>0.0) => return 1;
     end case;
  otherwise =>
     print("error in sign");
     return 0;
end case;
end sign;


end int_expr;
